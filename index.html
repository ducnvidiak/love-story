<!doctype html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" href="data:,‚ù§Ô∏è" />

    <title>A Lifetime Loving You üíñ</title>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        background: #000510;
        overflow: hidden;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      }
      canvas {
        display: block;
      }

      /* L·ªùi t·ªè t√¨nh xu·∫•t hi·ªán */
      #confession {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        color: #fff;
        z-index: 10;
        opacity: 0;
        animation: fadeIn 3s ease-in forwards;
        animation-delay: 2s;
        pointer-events: none;
      }

      #confession h1 {
        font-size: 48px;
        margin: 0;
        text-shadow:
          0 0 20px rgba(255, 100, 150, 0.8),
          0 0 40px rgba(255, 100, 150, 0.5);
        font-weight: 300;
        letter-spacing: 2px;
      }

      #confession p {
        font-size: 24px;
        margin: 20px 0;
        text-shadow: 0 0 10px rgba(255, 200, 220, 0.6);
        font-style: italic;
      }

      @keyframes fadeIn {
        to {
          opacity: 1;
        }
      }

      /* N√∫t t∆∞∆°ng t√°c */
      #interactive-buttons {
        position: absolute;
        bottom: 80px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10;
        opacity: 0;
        animation: fadeInUp 2s ease-in forwards;
        animation-delay: 5s;
        display: flex;
        gap: 20px;
      }

      @keyframes fadeInUp {
        from {
          opacity: 0;
          transform: translate(-50%, 30px);
        }
        to {
          opacity: 1;
          transform: translate(-50%, 0);
        }
      }

      .btn {
        padding: 15px 40px;
        font-size: 18px;
        border: 2px solid rgba(255, 100, 150, 0.8);
        background: rgba(255, 100, 150, 0.2);
        color: #fff;
        border-radius: 50px;
        cursor: pointer;
        transition: all 0.3s ease;
        text-shadow: 0 0 10px rgba(255, 100, 150, 0.8);
        backdrop-filter: blur(10px);
      }

      .btn:hover {
        background: rgba(255, 100, 150, 0.4);
        box-shadow: 0 0 30px rgba(255, 100, 150, 0.6);
        transform: scale(1.05);
      }

      /* Timeline */
      #timeline {
        position: absolute;
        left: 30px;
        top: 50%;
        transform: translateY(-50%);
        z-index: 10;
        color: #fff;
      }

      .timeline-item {
        margin: 30px 0;
        padding: 15px;
        background: rgba(255, 255, 255, 0.05);
        border-left: 3px solid rgba(255, 100, 150, 0.6);
        border-radius: 5px;
        backdrop-filter: blur(10px);
        cursor: pointer;
        transition: all 0.3s ease;
        max-width: 250px;
      }

      .timeline-item:hover {
        background: rgba(255, 100, 150, 0.15);
        transform: translateX(10px);
      }

      .timeline-date {
        font-size: 14px;
        color: #ffc0cb;
        margin-bottom: 5px;
      }

      .timeline-text {
        font-size: 16px;
      }

      /* ƒê·∫øm ng√†y */
      #day-counter {
        position: absolute;
        top: 30px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10;
        color: #fff;
        text-align: center;
        font-size: 20px;
        text-shadow: 0 0 15px rgba(255, 100, 150, 0.8);
      }

      #day-counter .number {
        font-size: 48px;
        font-weight: bold;
        color: #ff6496;
      }

      /* Popup messages */
      .popup-message {
        position: absolute;
        background: rgba(255, 100, 150, 0.3);
        color: #fff;
        padding: 20px 30px;
        border-radius: 20px;
        z-index: 15;
        backdrop-filter: blur(10px);
        border: 2px solid rgba(255, 100, 150, 0.5);
        animation: popupFade 4s ease-in-out forwards;
        pointer-events: none;
        box-shadow: 0 0 30px rgba(255, 100, 150, 0.4);
      }

      @keyframes popupFade {
        0% {
          opacity: 0;
          transform: translateY(20px);
        }
        10% {
          opacity: 1;
          transform: translateY(0);
        }
        90% {
          opacity: 1;
          transform: translateY(0);
        }
        100% {
          opacity: 0;
          transform: translateY(-20px);
        }
      }

      /* Music controls */
      #music-control {
        position: absolute;
        bottom: 30px;
        right: 30px;
        z-index: 10;
      }

      .music-btn {
        width: 60px;
        height: 60px;
        border-radius: 50%;
        border: 2px solid rgba(255, 100, 150, 0.8);
        background: rgba(255, 100, 150, 0.2);
        color: #fff;
        font-size: 24px;
        cursor: pointer;
        backdrop-filter: blur(10px);
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .music-btn:hover {
        background: rgba(255, 100, 150, 0.4);
        box-shadow: 0 0 20px rgba(255, 100, 150, 0.6);
      }

      /* Album ·∫£nh */
      #photo-album {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.95);
        z-index: 100;
        display: none;
        align-items: center;
        justify-content: center;
      }

      #photo-album.active {
        display: flex;
      }

      .album-content {
        max-width: 800px;
        max-height: 80%;
        position: relative;
      }

      .album-image {
        width: 100%;
        height: auto;
        border-radius: 10px;
        box-shadow: 0 0 50px rgba(255, 100, 150, 0.5);
      }

      .album-caption {
        color: #fff;
        text-align: center;
        margin-top: 20px;
        font-size: 20px;
        text-shadow: 0 0 10px rgba(255, 100, 150, 0.8);
      }

      .album-close {
        position: absolute;
        top: -50px;
        right: 0;
        color: #fff;
        font-size: 40px;
        cursor: pointer;
        transition: color 0.3s ease;
      }

      .album-close:hover {
        color: #ff6496;
      }

      /* Response screen */
      #response-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.95);
        z-index: 200;
        display: none;
        align-items: center;
        justify-content: center;
        flex-direction: column;
      }

      #response-screen.active {
        display: flex;
      }

      #response-screen h1 {
        font-size: 72px;
        color: #ff6496;
        text-shadow: 0 0 30px rgba(255, 100, 150, 0.8);
        margin: 0;
        animation: heartBeat 1.5s infinite;
      }

      @keyframes heartBeat {
        0%,
        100% {
          transform: scale(1);
        }
        10%,
        30% {
          transform: scale(1.1);
        }
        20%,
        40% {
          transform: scale(1.05);
        }
      }

      #response-screen p {
        font-size: 28px;
        color: #fff;
        margin-top: 30px;
        text-align: center;
        max-width: 600px;
        line-height: 1.6;
      }
    </style>
  </head>
  <body>
    <audio id="bg-music" loop>
      <source src="music.mp3" type="audio/mpeg" />
    </audio>

    <canvas id="canvas"></canvas>

    <!-- L·ªùi t·ªè t√¨nh -->
    <div id="confession">
      <h1>Anh Y√™u Em ‚ù§Ô∏è</h1>
      <p>"C√≥ con chim nho nh·ªè, ƒë·∫≠u tr√™n b√£i c·ªè xanh"</p>
      <p>"C√≥ t√¨nh y√™u kh√¥ng nh·ªè, v·∫´n lu√¥n d√†nh cho em"</p>
    </div>

    <!-- ƒê·∫øm ng√†y -->
    <div id="day-counter">
      <div>Ch√∫ng ta ƒë√£ b√™n nhau</div>
      <div class="number" id="days-count">0</div>
      <div>ng√†y tuy·ªát v·ªùi</div>
    </div>

    <!-- Timeline -->
    <div id="timeline">
      <div
        class="timeline-item"
        data-story="ƒê√≥ l√† l√∫c anh bi·∫øt, cu·ªôc ƒë·ªùi anh s·∫Ω kh√¥ng bao gi·ªù nh∆∞ c≈©..."
      >
        <div class="timeline-date">üìÖ 14/02/2024</div>
        <div class="timeline-text">Ng√†y ƒë·∫ßu ti√™n g·∫∑p nhau</div>
      </div>
      <div
        class="timeline-item"
        data-story="√Ånh m·∫Øt em trong ng√†y h√¥m ƒë√≥, anh nh·ªõ m√£i..."
      >
        <div class="timeline-date">üí´ 20/02/2024</div>
        <div class="timeline-text">L·∫ßn ƒë·∫ßu n·∫Øm tay</div>
      </div>
      <div
        class="timeline-item"
        data-story="Kho·∫£nh kh·∫Øc h·∫°nh ph√∫c nh·∫•t c·ªßa anh!"
      >
        <div class="timeline-date">‚ù§Ô∏è 01/03/2024</div>
        <div class="timeline-text">Ch√≠nh th·ª©c y√™u nhau</div>
      </div>
    </div>

    <!-- N√∫t t∆∞∆°ng t√°c -->
    <div id="interactive-buttons">
      <button class="btn" id="btn-yes">üíï Em c≈©ng y√™u anh</button>
      <button class="btn" id="btn-album">üì∏ K·ª∑ ni·ªám c·ªßa ch√∫ng ta</button>
      <button class="btn" id="btn-firework">üéÜ Ph√°o hoa</button>
    </div>

    <!-- Music control -->
    <div id="music-control">
      <button class="music-btn" id="music-toggle">üéµ</button>
    </div>

    <!-- Album ·∫£nh -->
    <div id="photo-album">
      <div class="album-content">
        <span class="album-close" id="album-close">&times;</span>
        <img src="" alt="Memory" class="album-image" id="album-img" />
        <div class="album-caption" id="album-caption"></div>
      </div>
    </div>

    <!-- Response screen -->
    <div id="response-screen">
      <h1>üíñ YAY! üíñ</h1>
      <p>
        Anh bi·∫øt m√†! Em v√† anh s·∫Ω lu√¥n b√™n nhau, v∆∞·ª£t qua m·ªçi kh√≥ khƒÉn, t·∫°o n√™n
        nh·ªØng k·ª∑ ni·ªám ƒë·∫πp nh·∫•t. Anh y√™u em nhi·ªÅu l·∫Øm! üíï‚ú®
      </p>
    </div>

    <script>
      /* ================= BASIC SETUP ================= */
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      window.addEventListener("resize", resize);
      resize();

      const PI = Math.PI;

      /* ================= HEART FORMULA ================= */
      function heartPoint(t) {
        return {
          x: 16 * Math.pow(Math.sin(t), 3),
          y:
            13 * Math.cos(t) -
            5 * Math.cos(2 * t) -
            2 * Math.cos(3 * t) -
            Math.cos(4 * t),
        };
      }

      /* ================= PARTICLES ================= */
      const particles = [];
      const TARGET = 2600;

      function getHeartPosition(t, depth) {
        const base = heartPoint(t);
        const r = (1 - depth) * 12;
        return { x: base.x * r, y: base.y * r };
      }

      while (particles.length < TARGET) {
        const t = Math.random() * 2 * PI;
        const depth = Math.pow(Math.random(), 1.5);
        const pos = getHeartPosition(t, depth);

        const isTopGroove = pos.y > 8 && Math.abs(pos.x) < 5;
        const isBottomIntersection = pos.y < -8 && Math.abs(pos.x) < 6;
        const isCenterLine = Math.abs(pos.x) < 0.5;

        let prob = Math.exp(-2.6 * depth);

        if (isTopGroove) {
          prob *= 0.25;
        } else if (isBottomIntersection) {
          prob *= 0.35;
        } else if (isCenterLine) {
          prob *= 0.4;
        }

        if (Math.random() > prob) continue;

        const horizontalJitter = (Math.random() - 0.5) * 0.25;

        particles.push({
          t,
          depth,
          size: 1.0,
          alpha: 0.3 + (1 - depth) * 0.6,
          jitterX: horizontalJitter,
          jitterY: (Math.random() - 0.5) * 0.12,
        });
      }

      /* ================= CH·∫§M NG·∫™U NHI√äN XUNG QUANH TR√ÅI TIM ================= */
      let ambientDots = [];

      function createAmbientDots() {
        ambientDots = [];
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;

        for (let i = 0; i < 300; i++) {
          const minDistance = 180;
          const maxDistance = 400;
          const distance =
            minDistance + Math.random() * (maxDistance - minDistance);
          const angle = Math.random() * 2 * PI;
          const x = cx + Math.cos(angle) * distance;
          const y = cy + Math.sin(angle) * distance;

          if (x > 0 && x < canvas.width && y > 0 && y < canvas.height) {
            ambientDots.push({
              x: x,
              y: y,
              size: 0.5 + Math.random() * 1.5,
              alpha: 0.2 + Math.random() * 0.4,
              hue:
                Math.random() > 0.8
                  ? { r: 255, g: 200, b: 220 }
                  : { r: 200, g: 180, b: 255 },
            });
          }
        }
      }

      createAmbientDots();
      window.addEventListener("resize", createAmbientDots);

      /* ================= V≈® TR·ª§ - STARS ================= */
      const stars = [];
      for (let i = 0; i < 800; i++) {
        stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          r: Math.random() * 1.8,
          brightness: 0.3 + Math.random() * 0.7,
          twinkleSpeed: 0.02 + Math.random() * 0.03,
          twinkleOffset: Math.random() * PI * 2,
        });
      }

      /* ================= CH√íM SAO L√ÉNG M·∫†N ================= */
      const constellations = [];

      function createConstellations() {
        constellations.length = 0;

        // Ch√≤m sao CUPID (th·∫ßn t√¨nh y√™u) - g√≥c tr√™n b√™n tr√°i
        const cupid = {
          name: "Cupid - Th·∫ßn T√¨nh Y√™u",
          color: [255, 150, 180],
          stars: [],
          lines: [],
        };

        const cupidX = canvas.width * 0.2;
        const cupidY = canvas.height * 0.25;
        const cupidScale = 60;

        // H√¨nh cung t√™n c·ªßa Cupid
        cupid.stars = [
          { x: cupidX, y: cupidY }, // ƒê·∫ßu cung
          { x: cupidX + cupidScale * 0.3, y: cupidY - cupidScale * 0.5 }, // Gi·ªØa cung
          { x: cupidX, y: cupidY - cupidScale }, // Cu·ªëi cung
          { x: cupidX + cupidScale * 0.8, y: cupidY - cupidScale * 0.5 }, // M≈©i t√™n
          { x: cupidX + cupidScale * 0.5, y: cupidY - cupidScale * 0.5 }, // Th√¢n t√™n
        ];

        cupid.lines = [
          [0, 1],
          [1, 2],
          [3, 4],
          [4, 1],
        ]; // N·ªëi c√°c ng√¥i sao
        constellations.push(cupid);

        // Ch√≤m sao TR√ÅI TIM ƒê√îI - g√≥c tr√™n b√™n ph·∫£i
        const doubleHeart = {
          name: "Tr√°i Tim ƒê√¥i",
          color: [255, 100, 150],
          stars: [],
          lines: [],
        };

        const dhX = canvas.width * 0.8;
        const dhY = canvas.height * 0.3;
        const dhScale = 40;

        // Tr√°i tim b√™n tr√°i
        doubleHeart.stars = [
          { x: dhX - dhScale, y: dhY },
          { x: dhX - dhScale * 0.5, y: dhY - dhScale * 0.3 },
          { x: dhX - dhScale, y: dhY - dhScale * 0.6 },
          { x: dhX - dhScale * 1.5, y: dhY - dhScale * 0.3 },
          // Tr√°i tim b√™n ph·∫£i
          { x: dhX + dhScale * 0.5, y: dhY },
          { x: dhX + dhScale, y: dhY - dhScale * 0.3 },
          { x: dhX + dhScale * 0.5, y: dhY - dhScale * 0.6 },
          { x: dhX, y: dhY - dhScale * 0.3 },
        ];

        doubleHeart.lines = [
          [0, 1],
          [1, 2],
          [2, 3],
          [3, 0], // Tr√°i tim tr√°i
          [4, 5],
          [5, 6],
          [6, 7],
          [7, 4], // Tr√°i tim ph·∫£i
          [1, 7], // N·ªëi 2 tim
        ];
        constellations.push(doubleHeart);

        // Ch√≤m sao INFINITY (v√¥ c·ª±c) - d∆∞·ªõi b√™n tr√°i
        const infinity = {
          name: "V√¥ C·ª±c - Y√™u M√£i M√£i",
          color: [200, 180, 255],
          stars: [],
          lines: [],
        };

        const infX = canvas.width * 0.15;
        const infY = canvas.height * 0.75;
        const infScale = 50;

        // K√Ω hi·ªáu ‚àû
        for (let i = 0; i <= 8; i++) {
          const t = (i / 8) * PI * 2;
          const x =
            infX + (infScale * Math.sin(t)) / (1 + Math.cos(t) * Math.cos(t));
          const y =
            infY +
            (infScale * Math.sin(t) * Math.cos(t)) /
              (1 + Math.cos(t) * Math.cos(t));
          infinity.stars.push({ x, y });
        }

        for (let i = 0; i < infinity.stars.length - 1; i++) {
          infinity.lines.push([i, i + 1]);
        }
        infinity.lines.push([infinity.stars.length - 1, 0]); // N·ªëi v√≤ng tr√≤n
        constellations.push(infinity);

        // Ch√≤m sao V·∫†N NƒÇM - g√≥c d∆∞·ªõi ph·∫£i
        const eternity = {
          name: "V·∫°n NƒÉm - Ng√†n ƒê·ªùi B√™n Em",
          color: [255, 200, 100],
          stars: [],
          lines: [],
        };

        const etX = canvas.width * 0.85;
        const etY = canvas.height * 0.7;
        const etScale = 45;

        // H√¨nh v∆∞∆°ng mi·ªán (crown)
        eternity.stars = [
          { x: etX - etScale, y: etY },
          { x: etX - etScale * 0.7, y: etY - etScale * 0.4 },
          { x: etX - etScale * 0.3, y: etY - etScale * 0.2 },
          { x: etX, y: etY - etScale * 0.7 },
          { x: etX + etScale * 0.3, y: etY - etScale * 0.2 },
          { x: etX + etScale * 0.7, y: etY - etScale * 0.4 },
          { x: etX + etScale, y: etY },
          { x: etX + etScale * 0.5, y: etY },
          { x: etX - etScale * 0.5, y: etY },
        ];

        eternity.lines = [
          [0, 1],
          [1, 2],
          [2, 3],
          [3, 4],
          [4, 5],
          [5, 6],
          [8, 0],
          [2, 8],
          [8, 7],
          [7, 4],
          [6, 7],
        ];
        constellations.push(eternity);

        // Ch√≤m sao CON ƒê∆Ø·ªúNG S·ªÆA - gi·ªØa tr√™n
        const milkyWay = {
          name: "C·∫ßu N·ªëi Ng√¢n H√†",
          color: [180, 200, 255],
          stars: [],
          lines: [],
        };

        const mwX = canvas.width * 0.5;
        const mwY = canvas.height * 0.15;
        const mwScale = 70;

        // C·∫ßu v·ªìng n·ªëi 2 b√™n
        for (let i = 0; i <= 6; i++) {
          const t = (i / 6) * PI;
          const x = mwX + (i - 3) * mwScale * 0.4;
          const y = mwY + Math.sin(t) * mwScale * 0.3;
          milkyWay.stars.push({ x, y });
        }

        for (let i = 0; i < milkyWay.stars.length - 1; i++) {
          milkyWay.lines.push([i, i + 1]);
        }
        constellations.push(milkyWay);

        // Th√™m ng√¥i sao s√°ng cho m·ªói ch√≤m sao
        constellations.forEach((cons) => {
          cons.stars.forEach((star) => {
            star.r = 2 + Math.random() * 1.5;
            star.brightness = 0.8 + Math.random() * 0.2;
            star.twinkleSpeed = 0.015 + Math.random() * 0.02;
            star.twinkleOffset = Math.random() * PI * 2;
          });
        });
      }

      createConstellations();
      window.addEventListener("resize", () => {
        createConstellations();
      });

      /* ================= D·∫¢I NG√ÇN H√Ä ================= */
      const galaxyParticles = [];
      for (let i = 0; i < 1500; i++) {
        const t = Math.random();
        const centerX = canvas.width * t;
        const centerY = canvas.height * (0.3 + t * 0.4);
        const spread = 80 + Math.random() * 120;
        const angle = Math.random() * PI * 2;

        galaxyParticles.push({
          x: centerX + Math.cos(angle) * spread * (Math.random() * 0.7),
          y: centerY + Math.sin(angle) * spread * (Math.random() * 0.3),
          r: Math.random() * 0.8,
          alpha: 0.1 + Math.random() * 0.3,
          color: Math.random() > 0.7 ? [180, 150, 255] : [200, 200, 255],
        });
      }

      /* ================= H√ÄNH TINH ================= */
      const planets = [
        {
          x: canvas.width * 0.15,
          y: canvas.height * 0.25,
          r: 35,
          color: [255, 180, 120],
          ringColor: [200, 150, 100],
          hasRing: true,
        },
        {
          x: canvas.width * 0.85,
          y: canvas.height * 0.7,
          r: 28,
          color: [120, 150, 255],
          hasRing: false,
        },
        {
          x: canvas.width * 0.08,
          y: canvas.height * 0.65,
          r: 18,
          color: [255, 100, 100],
          hasRing: false,
        },
      ];

      /* ================= SAO BƒÇNG ================= */
      const shootingStars = [];

      function createShootingStar() {
        if (Math.random() > 0.98) {
          shootingStars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height * 0.5,
            length: 60 + Math.random() * 80,
            speed: 8 + Math.random() * 6,
            angle: PI / 6 + (Math.random() * PI) / 6,
            life: 1.0,
          });
        }
      }

      /* ================= MOUSE TRAIL ================= */
      const mouseTrails = [];
      let mouseX = 0;
      let mouseY = 0;

      canvas.addEventListener("mousemove", (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;

        // T·∫°o tr√°i tim nh·ªè theo chu·ªôt
        for (let i = 0; i < 2; i++) {
          mouseTrails.push({
            x: mouseX + (Math.random() - 0.5) * 20,
            y: mouseY + (Math.random() - 0.5) * 20,
            size: 2 + Math.random() * 3,
            life: 1.0,
            vx: (Math.random() - 0.5) * 2,
            vy: -Math.random() * 2 - 1,
          });
        }
      });

      /* ================= FIREWORKS ================= */
      const fireworks = [];
      let fireworkMode = false;

      function createFirework() {
        const x = Math.random() * canvas.width;
        const y = canvas.height;
        const targetY = Math.random() * canvas.height * 0.5;

        fireworks.push({
          x: x,
          y: y,
          targetY: targetY,
          speed: 8,
          exploded: false,
          particles: [],
        });
      }

      /* ================= ROMANTIC HEARTBEAT ================= */
      let heartbeatIntensity = 1.0;

      function romanticHeartbeat(t) {
        const mainBeat = Math.sin(t * 3.2);
        const flutter = Math.sin(t * 6.4) * 0.3;
        const tremor = Math.sin(t * 1.6) * 0.15;
        const combined = (mainBeat + flutter + tremor + 1.5) / 3;
        return Math.pow(combined, 1.3) * 0.85 * heartbeatIntensity;
      }

      /* ================= POPUP MESSAGES ================= */
      const messages = [
        "Anh nghƒ© v·ªÅ em r·∫•t nhi·ªÅu...",
        "Em c√≥ bi·∫øt? N·ª• c∆∞·ªùi c·ªßa em l√†m anh tan ch·∫£y",
        "M·ªói ng√†y b√™n em l√† m·ªôt ng√†y tuy·ªát v·ªùi",
        "Anh mu·ªën ƒë∆∞·ª£c ·ªü b√™n em m√£i m√£i",
        "Em l√† ƒëi·ªÅu k·ª≥ di·ªáu nh·∫•t trong ƒë·ªùi anh",
      ];

      function showRandomMessage() {
        if (Math.random() > 0.995) {
          // Hi·∫øm khi xu·∫•t hi·ªán
          const msg = messages[Math.floor(Math.random() * messages.length)];
          const popup = document.createElement("div");
          popup.className = "popup-message";
          popup.textContent = msg;
          popup.style.left =
            20 + Math.random() * (window.innerWidth - 400) + "px";
          popup.style.top =
            100 + Math.random() * (window.innerHeight - 300) + "px";
          document.body.appendChild(popup);

          setTimeout(() => popup.remove(), 4000);
        }
      }

      /* ================= DAY COUNTER ================= */
      const startDate = new Date("2024-03-01"); // Thay ƒë·ªïi ng√†y c·ªßa b·∫°n
      function updateDayCounter() {
        const today = new Date();
        const diffTime = Math.abs(today - startDate);
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        document.getElementById("days-count").textContent = diffDays;
      }
      updateDayCounter();

      /* ================= EVENT LISTENERS ================= */

      // Timeline hover
      document.querySelectorAll(".timeline-item").forEach((item) => {
        item.addEventListener("mouseenter", function () {
          const story = this.dataset.story;
          const popup = document.createElement("div");
          popup.className = "popup-message";
          popup.textContent = story;
          popup.style.left = "320px";
          popup.style.top = this.offsetTop + "px";
          popup.id = "timeline-popup";
          document.body.appendChild(popup);
        });

        item.addEventListener("mouseleave", function () {
          const popup = document.getElementById("timeline-popup");
          if (popup) popup.remove();
        });
      });

      // N√∫t "Em c≈©ng y√™u anh"
      document.getElementById("btn-yes").addEventListener("click", () => {
        document.getElementById("response-screen").classList.add("active");
        heartbeatIntensity = 2.0;

        // T·∫°o nhi·ªÅu ph√°o hoa
        for (let i = 0; i < 10; i++) {
          setTimeout(() => createFirework(), i * 200);
        }

        setTimeout(() => {
          document.getElementById("response-screen").classList.remove("active");
          heartbeatIntensity = 1.0;
        }, 5000);
      });

      // N√∫t album
      const photos = [
        {
          src: "images/memory1.jpg",
          caption: "Kho·∫£nh kh·∫Øc ƒë·∫ßu ti√™n üíï",
          color: "#ff6496",
        },
        {
          src: "images/memory2.jpg",
          caption: "Ng√†y h·∫°nh ph√∫c nh·∫•t üåü",
          color: "#ff8fab",
        },
        {
          src: "images/memory3.jpg",
          caption: "M√£i b√™n nhau em nh√© üíñ",
          color: "#ffa6c1",
        },
      ];

      let currentPhoto = 0;

      document.getElementById("btn-album").addEventListener("click", () => {
        document.getElementById("photo-album").classList.add("active");
        showPhoto(0);
      });

      document.getElementById("album-close").addEventListener("click", () => {
        document.getElementById("photo-album").classList.remove("active");
      });

      function showPhoto(index) {
        currentPhoto = index;
        const photo = photos[index];

        const albumImg = document.getElementById("album-img");

        albumImg.src = photo.src;
        albumImg.style.background = "none";
        albumImg.style.display = "block";
        albumImg.style.height = "auto";

        document.getElementById("album-caption").textContent = photo.caption;
      }

      document.getElementById("album-img").addEventListener("click", () => {
        currentPhoto = (currentPhoto + 1) % photos.length;
        showPhoto(currentPhoto);
      });

      // N√∫t ph√°o hoa
      document.getElementById("btn-firework").addEventListener("click", () => {
        fireworkMode = !fireworkMode;
        if (fireworkMode) {
          heartbeatIntensity = 1.5;
        } else {
          heartbeatIntensity = 1.0;
        }
      });

      // Music control (placeholder)
      /* ================= MUSIC CONTROL ================= */
      const music = document.getElementById("bg-music");
      let musicPlaying = false;

      document.getElementById("music-toggle").addEventListener("click", () => {
        if (!musicPlaying) {
          music.volume = 0.6; // √Çm l∆∞·ª£ng d·ªãu
          music.play().catch(() => {});
          musicPlaying = true;
          document.getElementById("music-toggle").textContent = "‚è∏Ô∏è";
        } else {
          music.pause();
          musicPlaying = false;
          document.getElementById("music-toggle").textContent = "üéµ";
        }
      });

      /* ================= ANIMATION ================= */
      let time = 0;

      function drawGalaxy() {
        galaxyParticles.forEach((p) => {
          ctx.fillStyle = `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${p.alpha})`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, 2 * PI);
          ctx.fill();
        });
      }

      function drawStars() {
        stars.forEach((s) => {
          const twinkle =
            Math.sin(time * s.twinkleSpeed + s.twinkleOffset) * 0.3 + 0.7;
          const brightness = s.brightness * twinkle;

          ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
          ctx.beginPath();
          ctx.arc(s.x, s.y, s.r, 0, 2 * PI);
          ctx.fill();
        });
      }

      function drawConstellations() {
        constellations.forEach((cons) => {
          // V·∫Ω c√°c ƒë∆∞·ªùng n·ªëi
          cons.lines.forEach((line) => {
            const star1 = cons.stars[line[0]];
            const star2 = cons.stars[line[1]];

            // Hi·ªáu ·ª©ng ph√°t s√°ng
            const gradient = ctx.createLinearGradient(
              star1.x,
              star1.y,
              star2.x,
              star2.y,
            );

            const alpha = 0.3 + Math.sin(time * 0.5) * 0.15;
            gradient.addColorStop(
              0,
              `rgba(${cons.color[0]}, ${cons.color[1]}, ${cons.color[2]}, ${alpha})`,
            );
            gradient.addColorStop(
              0.5,
              `rgba(${cons.color[0]}, ${cons.color[1]}, ${cons.color[2]}, ${alpha * 0.6})`,
            );
            gradient.addColorStop(
              1,
              `rgba(${cons.color[0]}, ${cons.color[1]}, ${cons.color[2]}, ${alpha})`,
            );

            ctx.strokeStyle = gradient;
            ctx.lineWidth = 1.5;
            ctx.shadowBlur = 10;
            ctx.shadowColor = `rgba(${cons.color[0]}, ${cons.color[1]}, ${cons.color[2]}, 0.5)`;

            ctx.beginPath();
            ctx.moveTo(star1.x, star1.y);
            ctx.lineTo(star2.x, star2.y);
            ctx.stroke();

            ctx.shadowBlur = 0;
          });

          // V·∫Ω c√°c ng√¥i sao c·ªßa ch√≤m sao
          cons.stars.forEach((star) => {
            const twinkle =
              Math.sin(time * star.twinkleSpeed + star.twinkleOffset) * 0.3 +
              0.7;
            const brightness = star.brightness * twinkle;

            // H√†o quang
            const gradient = ctx.createRadialGradient(
              star.x,
              star.y,
              0,
              star.x,
              star.y,
              star.r * 3,
            );
            gradient.addColorStop(
              0,
              `rgba(${cons.color[0]}, ${cons.color[1]}, ${cons.color[2]}, ${brightness * 0.8})`,
            );
            gradient.addColorStop(
              0.5,
              `rgba(${cons.color[0]}, ${cons.color[1]}, ${cons.color[2]}, ${brightness * 0.3})`,
            );
            gradient.addColorStop(
              1,
              `rgba(${cons.color[0]}, ${cons.color[1]}, ${cons.color[2]}, 0)`,
            );

            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.r * 3, 0, 2 * PI);
            ctx.fill();

            // Ng√¥i sao ch√≠nh
            ctx.fillStyle = `rgba(255, 255, 255, ${brightness})`;
            ctx.beginPath();
            ctx.arc(star.x, star.y, star.r, 0, 2 * PI);
            ctx.fill();
          });

          // V·∫Ω t√™n ch√≤m sao (ch·ªâ hi·ªán khi hover g·∫ßn)
          if (cons.stars.length > 0) {
            const centerX =
              cons.stars.reduce((sum, s) => sum + s.x, 0) / cons.stars.length;
            const centerY =
              cons.stars.reduce((sum, s) => sum + s.y, 0) / cons.stars.length;

            const distToMouse = Math.sqrt(
              Math.pow(mouseX - centerX, 2) + Math.pow(mouseY - centerY, 2),
            );

            if (distToMouse < 150) {
              const labelAlpha = Math.max(0, 1 - distToMouse / 150);
              ctx.fillStyle = `rgba(${cons.color[0]}, ${cons.color[1]}, ${cons.color[2]}, ${labelAlpha * 0.9})`;
              ctx.font = '16px "Segoe UI", sans-serif';
              ctx.textAlign = "center";
              ctx.shadowBlur = 8;
              ctx.shadowColor = `rgba(${cons.color[0]}, ${cons.color[1]}, ${cons.color[2]}, ${labelAlpha})`;
              ctx.fillText(cons.name, centerX, centerY - 30);
              ctx.shadowBlur = 0;
            }
          }
        });
      }

      function drawPlanets() {
        planets.forEach((p) => {
          const gradient = ctx.createRadialGradient(
            p.x - p.r * 0.3,
            p.y - p.r * 0.3,
            p.r * 0.1,
            p.x,
            p.y,
            p.r,
          );
          gradient.addColorStop(
            0,
            `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, 1)`,
          );
          gradient.addColorStop(
            0.7,
            `rgba(${p.color[0] * 0.6}, ${p.color[1] * 0.6}, ${p.color[2] * 0.6}, 1)`,
          );
          gradient.addColorStop(
            1,
            `rgba(${p.color[0] * 0.3}, ${p.color[1] * 0.3}, ${p.color[2] * 0.3}, 1)`,
          );

          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, 2 * PI);
          ctx.fill();

          if (p.hasRing) {
            ctx.strokeStyle = `rgba(${p.ringColor[0]}, ${p.ringColor[1]}, ${p.ringColor[2]}, 0.6)`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.ellipse(p.x, p.y, p.r * 1.6, p.r * 0.4, 0, 0, 2 * PI);
            ctx.stroke();

            ctx.lineWidth = 2;
            ctx.strokeStyle = `rgba(${p.ringColor[0]}, ${p.ringColor[1]}, ${p.ringColor[2]}, 0.3)`;
            ctx.beginPath();
            ctx.ellipse(p.x, p.y, p.r * 1.8, p.r * 0.5, 0, 0, 2 * PI);
            ctx.stroke();
          }
        });
      }

      function drawShootingStars() {
        createShootingStar();

        for (let i = shootingStars.length - 1; i >= 0; i--) {
          const s = shootingStars[i];
          s.x += Math.cos(s.angle) * s.speed;
          s.y += Math.sin(s.angle) * s.speed;
          s.life -= 0.015;

          if (s.life <= 0) {
            shootingStars.splice(i, 1);
            continue;
          }

          const gradient = ctx.createLinearGradient(
            s.x,
            s.y,
            s.x - Math.cos(s.angle) * s.length,
            s.y - Math.sin(s.angle) * s.length,
          );
          gradient.addColorStop(0, `rgba(255, 255, 255, ${s.life * 0.9})`);
          gradient.addColorStop(0.5, `rgba(200, 220, 255, ${s.life * 0.5})`);
          gradient.addColorStop(1, "rgba(150, 180, 255, 0)");

          ctx.strokeStyle = gradient;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(s.x, s.y);
          ctx.lineTo(
            s.x - Math.cos(s.angle) * s.length * s.life,
            s.y - Math.sin(s.angle) * s.length * s.life,
          );
          ctx.stroke();

          ctx.fillStyle = `rgba(255, 255, 255, ${s.life})`;
          ctx.beginPath();
          ctx.arc(s.x, s.y, 2, 0, 2 * PI);
          ctx.fill();
        }
      }

      function drawAmbientDots() {
        ambientDots.forEach((dot) => {
          ctx.fillStyle = `rgba(${dot.hue.r}, ${dot.hue.g}, ${dot.hue.b}, ${dot.alpha})`;
          ctx.beginPath();
          ctx.arc(dot.x, dot.y, dot.size, 0, 2 * PI);
          ctx.fill();
        });
      }

      function drawMouseTrails() {
        for (let i = mouseTrails.length - 1; i >= 0; i--) {
          const trail = mouseTrails[i];
          trail.x += trail.vx;
          trail.y += trail.vy;
          trail.life -= 0.02;

          if (trail.life <= 0) {
            mouseTrails.splice(i, 1);
            continue;
          }

          // V·∫Ω tr√°i tim nh·ªè
          ctx.fillStyle = `rgba(255, 100, 150, ${trail.life})`;
          ctx.font = `${trail.size * 5}px Arial`;
          ctx.fillText("‚ù§Ô∏è", trail.x, trail.y);
        }
      }

      function drawFireworks() {
        if (fireworkMode && Math.random() > 0.97) {
          createFirework();
        }

        for (let i = fireworks.length - 1; i >= 0; i--) {
          const fw = fireworks[i];

          if (!fw.exploded) {
            fw.y -= fw.speed;

            ctx.fillStyle = "rgba(255, 200, 100, 0.8)";
            ctx.beginPath();
            ctx.arc(fw.x, fw.y, 3, 0, 2 * PI);
            ctx.fill();

            if (fw.y <= fw.targetY) {
              fw.exploded = true;
              // T·∫°o particles khi n·ªï
              for (let j = 0; j < 50; j++) {
                const angle = (Math.PI * 2 * j) / 50;
                fw.particles.push({
                  x: fw.x,
                  y: fw.y,
                  vx: Math.cos(angle) * (2 + Math.random() * 3),
                  vy: Math.sin(angle) * (2 + Math.random() * 3),
                  life: 1.0,
                  color: [
                    Math.random() * 255,
                    Math.random() * 255,
                    Math.random() * 255,
                  ],
                });
              }
            }
          } else {
            let allDead = true;
            fw.particles.forEach((p) => {
              p.x += p.vx;
              p.y += p.vy;
              p.vy += 0.1; // Gravity
              p.life -= 0.015;

              if (p.life > 0) {
                allDead = false;
                ctx.fillStyle = `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${p.life})`;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 2, 0, 2 * PI);
                ctx.fill();
              }
            });

            if (allDead) {
              fireworks.splice(i, 1);
            }
          }
        }
      }

      function drawHeart() {
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;

        const beat = romanticHeartbeat(time);

        particles.forEach((p) => {
          const base = heartPoint(p.t);
          const depthFactor = Math.pow(p.depth, 1.4);
          const minAmp = 0.18;
          const maxAmp = 0.55;
          const amplitude = minAmp + (maxAmp - minAmp) * depthFactor;
          const pulse = 1 + beat * amplitude;
          const r = (1 - p.depth + p.jitterY) * 12 * pulse;
          const x = cx + (base.x + p.jitterX) * r;
          const y = cy - base.y * r;

          const brightness = 1 + beat * 0.5;
          const red = Math.min(255, 255 * brightness);
          const green = Math.min(140, 110 * brightness);
          const blue = Math.min(200, 170 * brightness);
          const dynamicAlpha = p.alpha + beat * 0.15;

          ctx.fillStyle = `rgba(${red}, ${green}, ${blue}, ${dynamicAlpha})`;
          ctx.beginPath();
          ctx.arc(x, y, p.size, 0, 2 * PI);
          ctx.fill();
        });
      }

      function animate() {
        time += 0.045;

        ctx.fillStyle = "#000510";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        drawGalaxy();
        drawStars();
        drawConstellations(); // V·∫Ω c√°c ch√≤m sao
        drawPlanets();
        drawShootingStars();
        drawAmbientDots();
        drawFireworks();
        drawHeart();
        drawMouseTrails();

        showRandomMessage();

        requestAnimationFrame(animate);
      }

      animate();
    </script>
  </body>
</html>
